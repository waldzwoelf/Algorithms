\chapter{Introduction}
\section{Motivation}
The previous course has shown us how interesting problems can be solved with the
help of \blue{sets} and \blue{dictionaries}.  However, we did not discuss how these data structures can be
implemented in an efficient way.  This course will answer this question:  We will develop a number of different data structures
that can be used to implement both sets and dictionaries.  Furthermore, we will discuss a number of
other data structures and algorithms that should be in the toolbox of every computer scientist.

While the class in the last term has introduced the students to the theoretical foundations of
computer science, this class is more practical.  Indeed, it may be one of the most 
important classes for your future career: Five years after their students have graduated, Stanford University
regularly asks their former students to rank those classes that were the most useful for their professional
career.  Together with programming and databases, the class on algorithms consistently ranks highest.
On \href{https://quora.com}{Quora}, the answers to the question
\\[0.1cm]
\hspace*{0.8cm}
``\href{https://www.quora.com/What-are-the-5-most-important-CS-courses-that-every-computer-science-student-must-take}{
  What are the 5 most important CS courses that every computer science student must take?}''
\\[0.1cm]
consistently list the class \blue{algorithms and data structures} among those courses that are most valuable
for a professional career.  The practical importance of the topic of this class can also be seen by the
availability of book titles like
``\href{https://www.amazon.com/Algorithms-Interviews-Adnan-Aziz/dp/1453792996}{Algorithms for Interviews}''  
\cite{aziz:10} or the \href{http://www.youtube.com/watch?v=k4RRi_ntQc8}{Google job interview questions}.
 
 
\section{Overview}
This lecture covers the design and the analysis of algorithms.  We will discuss the following topics.
\begin{enumerate}
% \item Undecidability of the \href{http://en.wikipedia.org/wiki/Halting_problem}{halting problem}.

%       At the beginning of the lecture we discuss the limits of computability:  We will show that
%       there is no \textsc{SetlX} function \texttt{doesTerminate} such that for a given function $f$
%       of one argument and a string $s$ the expression
%       \\[0.2cm]
%       \hspace*{1.3cm}
%       $\texttt{doesTerminate}(f, s)$ 
%       \\[0.2cm]
%       yields \texttt{true} if the evaluation of $f(s)$ terminates and yields \texttt{false} otherwise.
\item \href{http://en.wikipedia.org/wiki/Computational_complexity_theory}{Complexity} \index{complexity} of algorithms

      In general, in order to solve a given problem it is not enough to develop an algorithm that
      implements a function $f$ computing the  value $f(x)$ for a given argument $x$.  It is also important  
      that the computation of $f(x)$ does not consume too much \blue{time} or \blue{memory}.  Hence, we have
      to develop \blue{efficient} algorithms.  In order to be able to discuss the concept of \blue{efficiency} 
      we discuss the \blue{growth rate} of functions.  This notation is useful to abstract from
      unimportant details when discussing the runtime of algorithms.  
% \item Recurrence Relations

%       The notion of a \href{http://en.wikipedia.org/wiki/Recurrence_relation}{recurrence relation}
%       \index{recurrence relation}
%       is the discrete analogue of the notion of a 
%       \href{http://en.wikipedia.org/wiki/Differential_equation}{differential equation}.
%       For example, the equation
%       \\[0.2cm]
%       \hspace*{1.3cm}
%       $a_{n+2} = a_{n+1} + a_n$
%       \\[0.2cm]
%       is a recurrence relation.  Together with the initial values $a_0 = 0$ and $a_1 = 1$, this equation
%       defines a sequence of natural numbers.  Later, we will see that this sequence can also be computed by
%       the formula
%       \\[0.2cm]
%       \hspace*{1.3cm}
%       $\ds a_{n} = \frac{1}{\sqrt{5}} \cdot \biggl(\frac{1+\sqrt{5}}{2}\biggr)^n - \frac{1}{\sqrt{5}} \cdot \biggl(\frac{1-\sqrt{5}}{2}\biggr)^n$.
%       \\[0.2cm]
%       Recurrence relations occur naturally when analysing the runtime of algorithms.  We present the 
%       \href{https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)}{Master Theorem} that can
%       be used to compute the growth of \blue{recursive} functions.
\item \blue{Correctness} of algorithms
      
      An algorithm is useless unless it is correct.  We discuss two methods to verify the correctness
      of an algorithm.
      \begin{enumerate}
      \item We first demonstrate the method of \blue{computational induction}.
            This method can be used to prove the correctness of recursive functions.
      \item Then we demonstrate the method of \blue{symbolic execution}, which can be used to verify functions
            that are implemented with the help of loops.
      \end{enumerate}
\item \href{http://en.wikipedia.org/wiki/Sorting_algorithm}{Sorting algorithms}

      Sorting algorithm are among those algorithms that are most frequently used in practice.  Furthermore,
      these algorithms are easy to understand and easy to analyse.  Therefore, we start our discussion of
      algorithms and their complexity with these algorithms.  In this lecture, we discuss the following
      sorting algorithms: 
      \begin{enumerate}
      \item \href{http://en.wikipedia.org/wiki/Insertion_sort}{insertion sort},
      \item \href{http://en.wikipedia.org/wiki/Merge_sort}{merge sort}, 
      \item \href{http://en.wikipedia.org/wiki/Quicksort}{quicksort}, 
      \item \href{http://en.wikipedia.org/wiki/Radix_sort}{radix sort}, and
      \item \href{https://en.wikipedia.org/wiki/Heapsort}{heapsort}.
      \end{enumerate}  
\item \href{http://en.wikipedia.org/wiki/Abstract_data_types}{Abstract data types}

      Abstract data types enable us to describe the behaviour of a data structure in a concise way.
      Furthermore, abstract data types are part of the foundations of 
      \href{https://en.wikipedia.org/wiki/Object-oriented_programming}{object-oriented programming}.
%\item \href{http://en.wikipedia.org/wiki/Hoare_logic}{Hoare logic}.
%  
%      The most important property of an algorithm is its correctness.  The \blue{Hoare calculus}
%      is a method to investigate the correctness of an algorithm.  

\item \href{http://en.wikipedia.org/wiki/Map_(computer_science)}{Dictionaries} and sets
  
      A \blue{dictionary} is a data structures that can be used to implement a function on a finite domain.
      Most modern programming languages provide dictionaries as basic data structures.  We discuss various data
      structures that can be used to implement dictionaries efficiently.   
      These data structures can also be used to implement sets.
\item \href{http://en.wikipedia.org/wiki/Priority_queue}{Priority queues}

      A \blue{priority queue} is a data structure that can best be described as a sorted list that remains
      sorted when elements are inserted or removed.
      Some \blue{graph theoretical} algorithms use \blue{priority queues} as one of their basic building blocks.
      Therefore, our discussion of \blue{graph theory} is preceded by a chapter on priority queues.
\item \blue{Data compression}

      There are basically two algorithms for loss-less data compression: The algorithm of Lempel, Ziv, and
      Welch and \blue{Huffman's} algorithm.  For reasons of space we will only discuss the latter algorithm.
\item \href{http://en.wikipedia.org/wiki/Graph_theory}{Graph theory}
  
      This chapter discusses the following algorithms:
      \begin{enumerate}
      \item \href{http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}{Dijkstra's algorithm}
            for computing the shortest path in a graph,
      \item \href{https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}{Kruskal's algorithm} for finding the
            \href{https://en.wikipedia.org/wiki/Minimum_spanning_tree}{minimum spanning tree} of a graph,
      \item \blue{topological sorting}, and 
      \item the \blue{union-find problem}.
      \end{enumerate}
\item \href{http://en.wikipedia.org/wiki/Monte_Carlo_method}{Monte Carlo Method} 
 
      Many important problems either do not have an exact solution at all or the computation of an
      exact solution would be prohibitively expensive.  In these cases it is often possible to use 
      \blue{random simulations} in order to get an approximate solution.  As a concrete example we will show
      how certain probabilities in \href{http://en.wikipedia.org/wiki/Texas_hold_%27em}{Texas hold 'em} 
      poker can be determined approximately with the help of the \blue{Monte Carlo method}.
\end{enumerate}
The primary goal of these lectures on algorithms is not to teach as many algorithms as possible.
Instead, my goal is to enable you to \blue{think} algorithmically:  At the end of these
lectures, you should have acquired the following capabilities:
\pagebreak
\begin{enumerate}
\item You should be able to read and understand scientific literature describing algorithms.
\item You should have acquired the skill to develop your own algorithms and to analyse their complexity.

      Of course, developing an algorithm is a process that requires a lot of creativity on your side.  However,
      once you are acquainted with a fair number of algorithms, you should be able to develop similar
      algorithms on your own. 
\end{enumerate}


\section{Algorithms and Programs}
This is a lecture on \blue{algorithms}, not on \blue{programming}.  It is important that you do not mix up
these two concepts.  An algorithm \index{algorithm} is an \blue{abstract concept} to solve a given problem.  In
contrast, a program is a \blue{concrete implementation} of an algorithm.  In order to implement an
algorithm as a program we have to cover every detail, be it trivial or not.  On the other hand, 
to specify an algorithm it is often sufficient to describe just the interesting aspects.  The rest can then be
filled in by a competent programmer.  Therefore, a specification of an algorithm often \blue{abstracts} from minor
details. 

In the literature, algorithms are usually presented as \blue{pseudo code}. \index{pseudo code}
Syntactically, pseudo code looks
similar to a program, but in contrast to a program, pseudo code can also contain parts that are only
described in natural language.   However, it is important to realize that a piece of pseudo code is
\underline{not} an algorithm but is only a \blue{representation} of an algorithm.  The
advantage of pseudo code is that we are not confined by the arbitrariness of the syntax of a
programming language.

Conceptually, the difference between an algorithm and a program is similar to the difference between
a \blue{philosophical idea} and a \blue{text} that describes the idea.  If you have an philosophical idea, you
can write it down to make it concrete.  As you can write down the idea in English, or French or, preferably, in
ancient Greek, the textual descriptions of the idea might be quite different.  This is the same with an algorithm:
We can code it in \href{https://en.wikipedia.org/wiki/C_(programming_language)}{\texttt{C}} or
\href{http://python.org}{Python}.  The programs will be very different, but the algorithm will be the same. 

Having discussed the difference between algorithms and programs, let us now decide how to present
algorithms in this lecture.  
\begin{enumerate}[(a)]
\item We can describe algorithms using natural language.  While natural language certainly is
      expressive enough, it also suffers from \blue{ambiguities}.  Furthermore, natural language
      descriptions of complex algorithms tend to be difficult to follow.
\item Instead, we can describe an algorithm by implementing it.  There is certainly no ambiguity
      in a program, but on the other hand this approach would require us to implement every aspect
      of an  algorithm and our descriptions of algorithms would therefore get longer than we want.
\item Finally, we can specify an algorithm \blue{mathematically}.  The language of mathematics is 
      concise, unambiguous, and easy to understand, once you are accustomed to it.  Therefore, this is
      our method of choice.

      However, after having presented an algorithm in the language of mathematics, it is often very
      straightforward to implement this algorithm in the programming language \textsl{Python}.
      Furthermore, this has the added benefit that we are able to test our algorithm.  For this reason we
      present \textsl{Python} implementations of all the algorithms covered in this lecture.
\end{enumerate}

\section{Desirable Properties of Algorithms}
Before we start with our discussion of algorithms we should think about our goals when designing
algorithms.  
\begin{enumerate}[(a)]
\item Algorithms have to be \blue{correct}.
\item Algorithms should be \blue{efficient} with respect to both \blue{computing time} and \blue{memory}.
\item Algorithms should be \blue{simple}.
\end{enumerate}
The first goal in this list is so self-evident that it is often overlooked.  The
importance of the last goal might not be as obvious as the other goals.
However, the reason for the last goal is \blue{economical}:  If it takes very long to code an algorithm, the
cost of the implementation might well be unaffordable.  Furthermore, even if the time budget to implement an
algorithm is next to unlimited,  there is another reasons to strife for simple algorithms:  If the conceptual
complexity of an algorithm is too high, maintenance might become a nightmare and it might be impossible to
guarantee the correctness of the implementation.  Therefore, the third goal is strongly related to the first goal.  

\section{Literature}
These lecture notes are intended to be the main source for my lecture.  Additionally, I want
to mention those books that have inspired me the most.
\begin{enumerate}
\item \textsl{Robert Sedgewick}: \href{https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X}{Algorithms}, 
      fourth edition, Pearson, 2011, \cite{sedgewick:11}.
    
      This book has a nice \href{http://algs4.cs.princeton.edu/home/}{booksite} containing a wealth
      of additional material.  This book seems to be the best choice for the working practitioner.
      Furthermore, \href{http://www.cs.princeton.edu/~rs/}{Professor Sedgewick} teaches an excellent 
      \href{https://www.coursera.org/course/algs4partI}{course} on algorithms that is available at
      \href{https://www.coursera.org/}{coursera.org}.  This course is based on this book.  Furthermore, all
      the algorithms discussed in this book are implemented in \textsl{Java}, so reading this book
      also strengthens your knowledge of \textsl{Java}.
\item \textsl{Alfred V.~Aho}, \textsl{John E.~Hopcraft}, and \textsl{Jeffrey D.~Ullman}:
      \blue{Data Structures and Algorithms}, Addison-Wesley, 1987, \cite{aho:87}.
      
      This book is a bit dated now but it is one of the classics on algorithms.  It discusses algorithms at an
      advanced level.
\item \textsl{Thomas H.~Cormen}, \textsl{Charles E.~Leiserson}, 
      \textsl{Ronald L.~Rivest}, and \textsl{Clifford Stein}:
      \href{https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844}{Introduction to Algorithms}, 
      third edition, MIT Press, 2009, \cite{cormen:09}

      Due to the level of detail and the number of algorithms given, this
      \href{https://en.wikipedia.org/wiki/Introduction_to_Algorithms}{book} can be viewed as a reference work. 
      This book requires more mathematical sophistication on the side of its readers than any of the
      other books referenced here.  
\item \blue{Einführung in die Informatik},
      written by \textsl{Heinz-Peter Gumm} and \textsl{Manfred Sommer} \cite{gumm:2013}.
      
      This German book is a very readable introduction to computer science and it has a chapter
      on algorithms that is fairly comprehensive.  
\item Furthermore, there is a set of outstanding 
      \href{https://class.coursera.org/algo-004/class/index}{video lectures} 
      from \href{http://theory.stanford.edu/~tim/}{Professor Roughgarden}
      available at \href{https://www.coursera.org/}{coursera.org}.
\end{enumerate}


\section{A Final Remark}
There is one final remark I would like to make at this point:  Frequently, I get questions from
students concerning the exam. \index{exam} While I will most gladly \dChangey[1.5][yellow]{2} answer these questions, I should warn you
that, unfortunately 50\%
of the time, my answers will be flat out \red{lies} \dChangey[1.5][red]{-2}.  The other 50\%,
my answers will be some \blue{random rubbish} \dVomey[2][green!80!black][brown].  Please bear that in mind when evaluating my answers. 
\pagebreak

\section{A Request}
Computer science is a very active field of research.  Furthermore, my comprehension of the English
language is improving steadily, or so I hope.  Therefore, these lecture notes are constantly
evolving and hence might contain typos or even mistakes.  If you find a problem,
please take the time and either send me an email or a message on discord.  My email address is
\\[0.2cm]
\hspace*{1.3cm}
\href{mailto:karl.stroetmann@dhbw-mannheim.de}{karl.stroetmann@dhbw-mannheim.de}.
\\[0.2cm]
If you are familiar with \href{http://github.com}{\texttt{github}}, you might even consider
sending me a \href{https://help.github.com/articles/using-pull-requests}{pull request}.

Finally, if you have any questions regarding the material presented in this course, you are
welcome to ask questions either by \href{mailto:karl.stroetmann@dhbw-mannheim.de}{email} or
\href{https://discordapp.com}{discord}.  If you think that others might
have the same question, it is best if you ask your question via the \href{https://discordapp.com}{discord}
server that I am using as a discussion forum for this lecture.  All your questions are welcome since they give
me valuable feedback  \blue{\st{how stupid you really are}} to improve my lecture. 


%%% local Variables: 
%%% mode: latex
%%% TeX-master: "algorithms"
%%% End: 
